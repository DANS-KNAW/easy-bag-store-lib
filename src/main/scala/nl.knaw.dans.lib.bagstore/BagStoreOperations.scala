/**
 * Copyright (C) 2018 DANS - Data Archiving and Networked Services (info@dans.knaw.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.knaw.dans.lib.bagstore

import java.io.{ OutputStream, File => JFile }
import java.util.UUID

import better.files._
import nl.knaw.dans.lib.bagstore.ArchiveStreamType.ArchiveStreamType

import scala.util.Try

/**
 * Declares the BagStore operations `ADD`, `GET`, `ENUM`, `DEACTIVATE`, `REACTIVATE` and `ERASE` as
 * abstract Scala methods.
 */
trait BagStoreOperations {

  /**
   * Implementation of the `ADD` operation.
   *
   * Adds a bag to the bag store. A UUID to use as bag-id may be provided. If it is not, it is
   * generated by the function. The bag must be virtually-valid in the context of this bag store.
   *
   * @param bag     the bag to add
   * @param optUuid the UUID to use as bag-id
   * @return the BagId of the added bag
   */
  def add(bag: BagFile, optUuid: Option[UUID] = None): Try[BagId]

  /**
   * Implementation of the `GET` operation.*
   *
   * Copies the referenced item to `target`. If target already exists, the function will
   * fail, unless `overwrite = true` is specified.
   *
   * @param itemId    the item to copy
   * @param target    the location to write item to
   * @param overwrite first remove existing file or directory in the target location
   * @return
   */
  def get(itemId: ItemId, target: File, overwrite: Boolean = false): Try[Unit]

  /**
   * Implementation of the `GET` operation.
   *
   * Writes the referenced item to `target` output stream. If an archive stream type is specified, the
   * item is packaged in the corresponding archive format (e.g., ZIP, TAR). For Bag and Directory items
   * this is mandatory.
   *
   * @param itemId               the item to write
   * @param target               the output stream to write the item to
   * @param optArchiveStreamType the archive stream type to use, if any
   * @return
   */
  def stream(itemId: ItemId, target: => OutputStream, optArchiveStreamType: Option[ArchiveStreamType] = None): Try[Unit]

  /**
   * Implementation of the `ENUM` operation.
   *
   * Enumerates all the bags in the bag store. By default only active bags will be returned. The optional boolean
   * parameters let you override this behavior.
   *
   * @param includeActive   whether to include the active bags
   * @param includeInactive whether to include include the deactivated bags
   * @return
   */
  def enumBags(includeActive: Boolean = true, includeInactive: Boolean = false): Try[Stream[Try[BagId]]]

  /**
   * Implementation of the `ENUM` operation.
   *
   * Enumerates the files in a bag. By default only regular files are returned. The optional boolean parameters let
   * you override this behavior.
   *
   * @param bagId               the bag to enumerate
   * @param includeRegularFiles whether to include regular files
   * @param includeDirectories  whether to include directories
   */
  def enumFiles(bagId: BagId, includeRegularFiles: Boolean = true, includeDirectories: Boolean = false): Try[Stream[Try[FileId]]]

  /**
   * Implementation of the `DEACTIVATE` operation.
   *
   * Deactivates a bag. An inactive bag should be considered deleted. However, the regular files in an
   * inactive bag can still be included through a local-file-uri into another bag.
   *
   * @param bagId the bag to deactivate.
   * @return
   */
  def deactivate(bagId: BagId): Try[Unit]

  /**
   * Implementation of the `REACTIVATE` operation.
   *
   * Reverse a previous deactivation.
   *
   * @param bag the inactive bag to reactivate
   * @return
   */
  def reactivate(bag: BagId): Try[Unit]

  /**
   * Implementation of the `ERASE` operation.
   *
   * This will cause the regular payload files referenced by `fileId` to be overwritten with a text message:
   *
   * {{{
   *   ERASED AT: <ISO 8601 TIMESTAMP OF ERASURE>
   *   BY: <authority>
   *   REASON: <reason>
   * }}}
   *
   * This records the provenance:
   *
   * - The exact time the erasure was initiated.
   * - The authority who performed the erasure. This should be the full name of a person authorized to
   * take the decision to remove data from the archive.
   * - The reason for the erasure, for example: contract with customer expired, legal obligation to
   * remove the data, etc.
   *
   * To avoid any risk to the referential integrity of the fetch references, this function temporarily
   * hides the base-dir of the bag store. It then proceeds to compile the list of payload manifests that
   * will need to be updated. Then it overwrites the files. Then it calculates the necessary checksums
   * and updates the manifests. Finally, it reactivates the bag store.
   *
   * @param fileId    the regular payload files to be erased
   * @param authority the authority under whose responsibility this actions is performed
   * @param reason    explanation why the data needs to be erased
   * @return
   */
  // TODO: Can we use a digital signing certificate to prove that the authority has indeed authorized the erasure?
  def erase(authority: String, reason: String, fileId: FileId*): Try[Unit]
}
