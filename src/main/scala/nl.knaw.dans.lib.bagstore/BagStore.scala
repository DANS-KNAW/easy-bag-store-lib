package nl.knaw.dans.lib.bagstore

import java.util.UUID

import better.files.File
import nl.knaw.dans.lib.logging.DebugEnhancedLogging

import scala.util.Try

/**
 * Represents an existing bag store. The bag store may be empty. If it already has content the onus is on the caller
 * to ensure that the other parameters are consistent with it.
 *
 * The staging directory `stagingDir` must be on the same partition as the bag store, so that an atomic
 * move operation is possible.
 *
 * @param baseDir         the base directory of the bag store
 * @param stagingDir      the directory to use for staging bags
 * @param dirPermissions  the permissions to set on directories added to the bag store
 * @param filePermissions the permissions to set on regular files added to the bag store
 * @param slashPattern    the slash pattern to use when creating containing directories for the bag
 */
class BagStore(val baseDir: File,
               val stagingDir: File,
               val dirPermissions: String = "r-xr-xr-x",
               val filePermissions: String = "r--r--r--",
               val slashPattern: SlashPattern = SlashPattern(2, 30)) extends DebugEnhancedLogging {
  /**
   * Adds a bag to the bag store. A UUID to use as bag-id may be provided. If it is not, it is
   * generated by the function. The bag must be virtually-valid in the context of this bag store,
   * otherwise the function fails. Note that it may be possible to [[prune]] the bag before adding it.
   *
   * By default, a copy of `bag` will be staged staged to `stagingDir`. However, the caller can skip this
   * step and have `bag` be moved into the bag store from its current location. In that case, the current
   * location must be on the same partition as the bag store itself, so that an atomic move operation is
   * possible.
   *
   * A hidden file cannot be added to the bag store, as it would result in a bag that starts off inactive.
   *
   * @param bag     the bag to add
   * @param optUuid the UUID to use as bag-id
   * @param move    move (instead of copy) the bag into the bag store*
   * @return the added [[BagItem]]
   */
  def add(bag: File, optUuid: Option[UUID] = None, move: Boolean = false): Try[BagItem] = {
    trace(bag, optUuid, move)

    def checkArgs = Try {
      require(!bag.isHidden, "Input bag must be a non-hidden file")
    }

    def getUuid = Try {
      optUuid.getOrElse {
        UUID.randomUUID()
      }
    }

    def stageBagIfRequired = Try {
      if (move) {
        debug("Bag to be moved. No staging necessary.")
        bag
      }
      else {
        val tempDir = File.newTemporaryDirectory(parent = Some(stagingDir))
        debug(s"Created temp dir to stage bag to at: $tempDir")
        bag copyToDirectory tempDir
      }
    }

    def checkVirtuallyValid(bag: File) = Try {

    }

    def createContainer(uuid: UUID) = Try {
      val container = baseDir / slashPattern.applyTo(uuid).toString
      container.createDirectories()
      container.path.iterator()

      // TODO: set all the folders in the path to rwxrwxr--
      container
    }

    def moveBagInto(container: File)(bag: File) = Try {
      // Set permissions on descendants of bag
      bag moveToDirectory container
      // Set permissions on bag itself
      // If move fails, delete the empty directories in the container path
    }

    for {
      _ <- checkArgs
      bagToMove <- stageBagIfRequired
      _ <- checkVirtuallyValid(bagToMove)
      uuid <- getUuid
      container <- createContainer(uuid)
      _ <- if (move) moveBagInto(container)(bagToMove)
           // Make parent dir self-destruct after operation.
           else bagToMove.parent.toTemporary {
             _ => moveBagInto(container)(bagToMove)
           }
    } yield BagItem(this, uuid)
  }

  def get(itemId: ItemId): Try[Item] = {

    ???
  }

  def get(bagId: BagId): Try[BagItem] = {

    ???
  }

  def get(fileId: FileId): Try[FileItem] = {

    ???
  }

  def get(regularFileItem: RegularFileItem): Try[RegularFileItem] = {

    ???
  }

  def get(directoryItem: DirectoryItem): Try[DirectoryItem] = {

    ???
  }

  def enum(includeActive: Boolean = true, includeInactive: Boolean = false): Try[Stream[Try[BagItem]]] = {


    ???
  }

  /**
   * Verifies this bag store. The following invariants are checked (in this order):
   *
   * 1. The slash-pattern is maintained throughout the bag store.
   * 2. Every container only has one file in it.
   * 3. All bags are virtually-valid.
   *
   * If any of these invariants is violated the bag store is declared corrupt. By default the function will
   * stop at the first violation, but this behavior can be overridden.
   *
   * Note that, depending on the size of the bag store, this function may take a long time to complete.
   *
   * @param failOnFirstViolation whether to stop checking after encountering the first violation
   * @return
   */
  def verify(failOnFirstViolation: Boolean = true): Try[Unit] = {


    ???
  }


  /**
   * Determines whether `bag` is virtually-valid with respect to this bag store. The bag may or may not be
   * stored in the bag store currently.
   *
   * @param bag the bag to validate
   * @return if the bag is virtually-valid
   */
  def isVirtuallyValid(bag: File): Try[Unit] = {


    ???
  }

  /**
   * Removes from `bag` the payload files which are found in one of the reference bags and adds a fetch reference to
   * the file in that reference bag. The result is a smaller bag, which is still virtually valid relative to this
   * bag store.
   *
   * @param bag
   * @param refBagId
   */
  def prune(bag: File, refBagId: BagId*): Try[Unit] = {
    ???
  }


  /**
   *
   *
   * @param bag
   */
  def complete(bag: File): Try[Unit] = {
    ???
  }


}
